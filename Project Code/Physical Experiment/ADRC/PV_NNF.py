import numpy as np

def my_NNF (X):
    #MYNEURALNETWORKFUNCTION neural network simulation function.
    #
    # Auto-generated by MATLAB, 04-Jul-2023 17:20:54.
    #
    # [Y] = myNeuralNetworkFunction(X,~,~) takes these arguments:
    #
    #   X = 1xTS cell, 1 inputs over TS timesteps
    #   Each X{1,ts} = 3xQ matrix, input #1 at timestep ts.
    #
    # and returns:
    #   Y = 1xTS cell of 1 outputs over TS timesteps.
    #   Each Y{1,ts} = 3xQ matrix, output #1 at timestep ts.
    #
    # where Q is number of samples (or series) and TS is the number of timesteps.

    ##ok<*RPMT0>
    # ===== MODULE FUNCTIONS ========

    # Map Minimum and Maximum Input Processing Function
    def mapminmax_apply(x,settings):
        y = x - settings["xoffset"]
        y = y * settings["gain"]
        y = y + settings["ymin"]
        return y

    # Sigmoid Symmetric Transfer Function
    def tansig_apply(n):
        a = 2./(1 + np.exp(-2*n)) - 1
        return a

    # Map Minimum and Maximum Output Reverse-Processing Function
    def mapminmax_reverse(y,settings):
        x = y - settings["ymin"]
        x = x / settings["gain"]
        x = x + settings["xoffset"]
        return x
    

    # ===== NEURAL NETWORK CONSTANTS =====

    # Input 1
    x1_step1 = {
        "xoffset": np.array([[-0.698],[-0.603],[-0.684]]),
        "gain": np.array([[1.50489089541008],[1.53374233128834],[1.44717800289436]]),
        "ymin": -1
        }

    
##    x1_step1.xoffset = [-0.663147577012482],[-0.574862557533306],[-0.399803210312296]],[
##    x1_step1.gain = [1.50727710092582],[1.73954623917569],[2.41923359521101]],[
##    x1_step1.ymin = -1;

    # Layer 1
    b1 = np.array([[3.5662912778417847903],[2.7154537357153727406],[0.20149168505198589152],[-0.24221758574655910534],[0.14351475111337003154],[-0.242559580791079199],[-1.2465950082888623829],[-1.8710684985810053238],[-3.4912940863512793577],[-2.5547323701784998562]])

    IW1_1 = np.array([[-1.940032726469233193,1.0443962631460501633,-0.60843070460587656001],[-0.57784360683152247162,0.086128126431928159201,-2.433594159223817055],[-1.0599549428775096871,0.70484822879685160579,-0.69581214902881738382],[0.37696768346235776104,-1.472875326724177647,-1.0262085449279083615],[0.23225876054685520855,0.65456845685821773984,0.037463992074968192891],[1.3399231648987497412,0.58045549518406991396,-0.94133448487657589432],[-1.1156446354444959912,-0.18785350988914434334,2.0090512881331696882],[-1.9185366323038655079,-0.63141427851495457446,2.5554510688611320468],[-2.8082360932386247754,-1.6826176539491595197,1.2770440218079777139],[-1.9155055192123255914,-1.805979393112302045,-0.30073705694807184585]])
    
    
    # Layer 2
    b2 = np.array([[-0.792014229606405884],[-0.36871445689474485752],[-0.58753722370507099892]])
    LW2_1 = np.array([[-0.37233515215562074108,0.72508249027704851919,-0.27718265452902524082,-0.74146958264840590047,1.7497948246382701853,-0.1981829884103356032,-0.20616246812506242025,0.42960531929695067177,-0.94164693641821894943,0.58135807791823723711],[-0.099003879853945681022,0.44190562700466190504,-0.036460164588407339981,-0.20245044976302653539,-0.49717173233462502724,-0.84709438805947545603,-0.3231326434133103831,0.45168117632722970534,-0.40460925254301055576,0.37492562106947446843],[-0.11059472159405531189,0.65301278877454216332,-1.4254881516680277809,-0.25070659054549976341,-0.31269714798002468115,0.17652656625104157229,0.20753329966095204751,0.014245542439145057051,-0.97740758538720429183,0.63878412863690481327]])

    # Output 1
    y1_step1 = {
        "xoffset": np.array([[-1.000000000000],[-1.000000000000],[-1.0000000000000]]),
        "gain": np.array([[1],[1],[1]]),
        "ymin": -1
        }


    # ===== SIMULATION ========

##    # Format Input Arguments
##    isCellX = iscell(X);
##    if not X:
##        X = {X};
##    end

    # Dimensions
    TS = X.shape[1] # timesteps
    

    # Allocate Outputs
    Y = np.zeros(X.shape)

    # Time loop
    for ts in range(TS):

        # Input 1
        Xp1 = mapminmax_apply(X[:,ts].reshape(3,1),x1_step1)

        # Layer 1
        a1 = tansig_apply(np.repeat(b1,1,axis =1) + np.matmul(IW1_1,Xp1))

        # Layer 2
        a2 = np.repeat(b2,1,axis =1) + np.matmul(LW2_1,a1)

        #print(Xp1)

        # Output 1
        Y[:,ts] = mapminmax_reverse(a2,y1_step1).reshape(1,-1)


##    # Final Delay States
##    Xf = cell(1,0);
##    Af = cell(2,0);

##    # Format Output Arguments
##    if ~isCellX
##        Y = cell2mat(Y);
##    end
##    end
    return Y

##
##if __name__ == '__main__':
##    print(my_NNF(np.array([[0.5,0.2],[0,0],[0,0]])))
